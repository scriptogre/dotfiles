# Fix invalid locale from JetBrains/macOS (BCP 47 format not supported by bash)
if [[ "$LC_ALL" == *-u-* ]]; then
  export LC_ALL="en_US.UTF-8"
fi

# Load p10k configuration if it exists
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

# Powerlevel10k settings
POWERLEVEL9K_PROMPT_ON_NEWLINE=true

# 1Password SSH agent (configured via home-manager programs.ssh)

# Writable npm global prefix (shadows Nix packages when needed)
export NPM_CONFIG_PREFIX="$HOME/.npm-global"
export PATH="$HOME/.npm-global/bin:$PATH"

alias rsynca='rsync -avzP'

# Claude Code multi-account isolation
# Each function uses a separate config directory for independent login sessions
# History is shared via symlink; projects are separate to avoid sessions-index.json race conditions
_claude_shared_init() {
  local config_dir="$CLAUDE_CONFIG_DIR"
  local all_accounts=(.claude-1 .claude-2 .claude-3 .claude-4 .claude-5 .claude-6 .claude-oncogen)

  mkdir -p "$config_dir/projects"

  # Symlink history (append-only, safe for concurrent access)
  ln -sf "$HOME/.claude/history.jsonl" "$config_dir/history.jsonl" 2>/dev/null

  # Sync session files from all other accounts to this account
  # This enables --resume to find sessions started on other accounts
  # Each account keeps its own sessions-index.json (avoids race condition)
  for account in "${all_accounts[@]}"; do
    local src="$HOME/$account/projects"
    [[ -d "$src" && "$src" != "$config_dir/projects" ]] || continue

    # Sync *.jsonl session files (but NOT sessions-index.json)
    for project_dir in "$src"/*(/N); do
      local project_name="${project_dir:t}"
      local dest_project="$config_dir/projects/$project_name"
      mkdir -p "$dest_project"

      for session_file in "$project_dir"/*.jsonl(N); do
        local session_name="${session_file:t}"
        [[ "$session_name" == "sessions-index.json" ]] && continue
        local dest_file="$dest_project/$session_name"
        # Only copy if source is newer or dest doesn't exist
        [[ -f "$dest_file" && "$dest_file" -nt "$session_file" ]] || cp -p "$session_file" "$dest_file" 2>/dev/null
      done
    done
  done
}
claude-1() { export CLAUDE_CONFIG_DIR="$HOME/.claude-1"; _claude_shared_init; claude "$@"; }
claude-2() { export CLAUDE_CONFIG_DIR="$HOME/.claude-2"; _claude_shared_init; claude "$@"; }
claude-3() { export CLAUDE_CONFIG_DIR="$HOME/.claude-3"; _claude_shared_init; claude "$@"; }
claude-4() { export CLAUDE_CONFIG_DIR="$HOME/.claude-4"; _claude_shared_init; claude "$@"; }
claude-5() { export CLAUDE_CONFIG_DIR="$HOME/.claude-5"; _claude_shared_init; claude "$@"; }
claude-6() { export CLAUDE_CONFIG_DIR="$HOME/.claude-6"; _claude_shared_init; claude "$@"; }
claude-oncogen() { export CLAUDE_CONFIG_DIR="$HOME/.claude-oncogen"; _claude_shared_init; claude "$@"; }

# -----------------------------------------------------------------------------
# finda: search for filenames or directory names locally or on a remote host,
# and allow Ctrl+C to interrupt both local and remote searches.
# Usage: finda [<host>:]<path> <pattern>
# Example (local):  finda . foobar
# Example (remote): finda expert_systems:/home/usergpu foobar
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# finda: search for filenames or directory names locally or on a remote host,
# allowing Ctrl+C to interrupt without killing your shell.
# Usage: finda [<host>:]<path> <pattern>
# Example (local):  finda . foobar
# Example (remote): finda expert_systems:/home/usergpu foobar
# -----------------------------------------------------------------------------
finda() {
  if [[ $# -lt 2 ]]; then
    echo "Usage: finda [<host>:]<path> <pattern>"
    return 1
  fi

  local TARGET="$1"
  local PATTERN="$2"

  # Note: using only -iname "*$PATTERN*" will match both files and directories.
  if [[ "$TARGET" == *:* ]]; then
    local HOST="${TARGET%%:*}"
    local REMOTE_PATH="${TARGET#*:}"
    ssh "$HOST" "find '$REMOTE_PATH' -iname '*$PATTERN*' 2>/dev/null"
  else
    find "$TARGET" -iname "*$PATTERN*" 2>/dev/null
  fi
}

alias port='f() { lsof -nP -iTCP:"$1" -sTCP:LISTEN 2>/dev/null; }; f'
alias killport='f() { pid=$(lsof -nP -iTCP:"$1" -sTCP:LISTEN -t 2>/dev/null); if [ "$pid" ]; then kill -9 "$pid" && echo "Killed PID $pid on port $1"; else echo "Nothing on port $1"; fi; }; f'

alias cat='bat --paging=never'
alias ls='eza --tree --level=1 --icons=always'
alias nano='micro'

compress() {
  [[ -z "$1" || ! -f "$1" ]] && { echo "Usage: compress <input> [output]"; return 1; }

  in="$1"
  out="${2:-${in%.*}_compressed.${in##*.}}"
  ext_in="${in##*.}"
  ext_out="${out##*.}"

  case "$ext_in" in
    mp4|mov|mkv|avi|webm)
      echo "Compressing video: $in ‚Üí $out"
      ffmpeg -i "$in" -vf "scale=-2:1080:flags=lanczos" -c:v libx264 -preset slow -crf 23 \
             -c:a aac -b:a 128k -movflags +faststart "$out" -y ;;
    png)
      echo "Compressing PNG: $in ‚Üí $out"
      # Get original size
      size_before=$(stat -f%z "$in" 2>/dev/null || stat -c%s "$in" 2>/dev/null)

      # Step 1: Lossy compression with pngquant
      temp_pngquant="${out%.png}-temp.png"
      pngquant --quality 65-80 --speed 1 --strip --skip-if-larger "$in" --output "$temp_pngquant" 2>/dev/null

      # If pngquant succeeded, use its output; otherwise use original
      if [[ -f "$temp_pngquant" ]]; then
        pngquant_input="$temp_pngquant"
      else
        echo "‚ö†Ô∏è  pngquant skipped (would increase size), proceeding with original"
        pngquant_input="$in"
      fi

      # Step 2: Lossless compression with oxipng
      oxipng -o max --strip safe --alpha "$pngquant_input" --out "$out" 2>/dev/null

      # Cleanup temp file
      [[ -f "$temp_pngquant" ]] && rip "$temp_pngquant"

      # Calculate size reduction
      if [[ -f "$out" ]]; then
        size_after=$(stat -f%z "$out" 2>/dev/null || stat -c%s "$out" 2>/dev/null)
        size_diff=$((size_before - size_after))

        # Convert to human readable
        size_before_hr=$(numfmt --to=iec-i --suffix=B $size_before 2>/dev/null || echo "$size_before bytes")
        size_after_hr=$(numfmt --to=iec-i --suffix=B $size_after 2>/dev/null || echo "$size_after bytes")
        size_diff_hr=$(numfmt --to=iec-i --suffix=B $size_diff 2>/dev/null || echo "$size_diff bytes")

        # Calculate percentage (multiply before divide to avoid zero)
        percent_reduction=$((size_diff * 100 / size_before))

        echo "üìä $size_before_hr ‚Üí $size_after_hr (saved $size_diff_hr, -${percent_reduction}%)"
      fi
      ;;
    jpg|jpeg|webp|gif)
      echo "Compressing image: $in ‚Üí $out"
      size_before=$(stat -f%z "$in" 2>/dev/null || stat -c%s "$in" 2>/dev/null)

      magick "$in" -strip -interlace Plane -quality 85 "$out"

      if [[ -f "$out" ]]; then
        size_after=$(stat -f%z "$out" 2>/dev/null || stat -c%s "$out" 2>/dev/null)
        size_diff=$((size_before - size_after))

        size_before_hr=$(numfmt --to=iec-i --suffix=B $size_before 2>/dev/null || echo "$size_before bytes")
        size_after_hr=$(numfmt --to=iec-i --suffix=B $size_after 2>/dev/null || echo "$size_after bytes")
        size_diff_hr=$(numfmt --to=iec-i --suffix=B $size_diff 2>/dev/null || echo "$size_diff bytes")

        percent_reduction=$((size_diff * 100 / size_before))

        echo "üìä $size_before_hr ‚Üí $size_after_hr (saved $size_diff_hr, -${percent_reduction}%)"
      fi
      ;;
    *)
      echo "Unsupported file type: $ext_in"; return 1 ;;
  esac

  [[ $? -eq 0 ]] && echo "‚úÖ Done: $out" || echo "‚ùå Failed."
}

removebg() {
  [[ -z "$1" || ! -f "$1" ]] && { echo "Usage: removebg <input> [output]"; return 1; }

  in="$1"
  out="${2:-${in%.*}_nobg.png}"

  echo "Removing background: $in ‚Üí $out"
  uv tool run --python 3.11 'rembg[cli,cpu]' i "$in" "$out"

  [[ $? -eq 0 ]] && echo "‚úÖ Done: $out" || echo "‚ùå Failed."
}

# Auto-commit function that generates commit messages using Claude
commit() {
  # Check if we're in a git repo
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "‚ùå Not in a git repository"
    return 1
  fi

  # Check if there are changes to commit
  if git diff --quiet && git diff --cached --quiet; then
    echo "‚ÑπÔ∏è  No changes to commit"
    return 0
  fi

  # Get recent commit messages for pattern detection
  local recent_commits=$(git log -10 --pretty=format:"%s" 2>/dev/null | head -n 10)

  # Use Claude Code to analyze changes and create commit
  echo "ü§ñ Analyzing changes and creating commit..."
  claude "Create a git commit with the current changes and push it to the remote repository.

Recent commit messages from this repository (for pattern detection):
${recent_commits}

If the recent commits follow a clean, consistent pattern, match that style. Otherwise, use a short, concise imperative sentence starting with a titlecase verb (e.g., 'Add ...', 'Update ...', 'Fix ...'). The message should describe what capabilities or features now exist (not the development process). Keep it focused and professional."
}

command -v direnv &>/dev/null && eval "$(direnv hook zsh)"

# vast.ai sunshine game streaming (macOS only)
[[ -f "$HOME/Projects/dotfiles/common/shell/sunshine.zsh" ]] && source "$HOME/Projects/dotfiles/common/shell/sunshine.zsh"